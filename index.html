<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abel's Goofy Executables</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 50px;
            background-color: #f0f0f0;
        }
        h1 {
            color: #333;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }
        button:hover {
            background-color: #0056b3;
        }
        textarea {
            display: none; /* Hide the textarea */
        }
    </style>
</head>
<body>
    <h1>Abel's Goofy Executables</h1>
    <p>Click a button below to copy the code:</p>
    <button onclick="copyDVDCode()">DVD-logo</button>
    <button onclick="copyShrekCode()">Shrek</button>
    <button onclick="copyKachowCode()">Kachow</button>
    <button onclick="copyMinecraftCode()">Minecraft</button>
    <button onclick="copyAntsCode()">Ants</button>
    <button onclick="copyFishCode()">Fish</button>
    <button onclick="copySpaceCode()">Space</button>

    <!-- Hidden textarea for DVD-logo code -->
    <textarea id="dvdCode">
(function() {
    // Create a container for the shrunken website
    const container = document.createElement('div');
    container.style.position = 'fixed';
    container.style.top = '0';
    container.style.left = '0';
    container.style.width = '50%'; // Shrink to 50% of original size
    container.style.height = '50%'; // Shrink to 50% of original size
    container.style.transformOrigin = 'top left';
    container.style.overflow = 'hidden';
    container.style.zIndex = '9999';
    container.style.backgroundColor = 'white'; // Optional: Add background color

    // Create a wrapper to hold the body's children
    const wrapper = document.createElement('div');
    while (document.body.firstChild) {
        wrapper.appendChild(document.body.firstChild);
    }

    // Append the wrapper to the container
    container.appendChild(wrapper);

    // Append the container to the body
    document.body.appendChild(container);

    // Bouncing logic
    let posX = 0;
    let posY = 0;
    let velocityX = 2;
    let velocityY = 2;
    const speed = 2;

    function bounce() {
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;

        posX += velocityX;
        posY += velocityY;

        // Check for collision with the right or left edge
        if (posX + containerWidth > windowWidth || posX < 0) {
            velocityX = -velocityX;
        }

        // Check for collision with the bottom or top edge
        if (posY + containerHeight > windowHeight || posY < 0) {
            velocityY = -velocityY;
        }

        // Update the position of the container
        container.style.left = `${posX}px`;
        container.style.top = `${posY}px`;

        requestAnimationFrame(bounce);
    }

    // Start the bouncing animation
    bounce();
})();
    </textarea>

    <!-- Hidden textarea for Shrek code -->
    <textarea id="shrekCode">
// Function to replace the clicked element with an image of Shrek
function replaceWithShrek(event) {
    // Create a new image element
    const shrekImage = document.createElement('img');
    
    // Set the source of the image to a Shrek picture
    shrekImage.src = 'https://upload.wikimedia.org/wikipedia/en/4/4d/Shrek_%28character%29.png';
    
    // Set some styles to make the image fit well
    shrekImage.style.maxWidth = '100%';
    shrekImage.style.height = 'auto';
    
    // Replace the clicked element with the Shrek image
    event.target.replaceWith(shrekImage);
}

// Add a click event listener to the document
document.addEventListener('click', function(event) {
    // Check if the clicked element is not the body or html
    if (event.target !== document.body && event.target !== document.documentElement) {
        replaceWithShrek(event);
    }
});

console.log('Shrekify activated! Click any object to turn it into Shrek.');
    </textarea>

    <!-- Hidden textarea for Kachow code -->
    <textarea id="kachowCode">
// Create a new image element for Lightning McQueen
const mcqueen = document.createElement('img');
mcqueen.src = 'https://www.pngall.com/wp-content/uploads/14/Lightning-Mcqueen-PNG-Photos.png'; // New image URL of Lightning McQueen
mcqueen.style.position = 'fixed';
mcqueen.style.width = '100px'; // Adjust size as needed
mcqueen.style.height = 'auto';
mcqueen.style.transition = 'left 0.1s, top 0.1s'; // Smooth movement
mcqueen.style.pointerEvents = 'none'; // Ensure the image doesn't interfere with clicks
document.body.appendChild(mcqueen);

// Function to make Lightning McQueen follow the mouse
document.addEventListener('mousemove', function(event) {
    const mouseX = event.clientX;
    const mouseY = event.clientY;

    // Calculate the position for Lightning McQueen to follow the mouse
    const mcqueenX = mouseX - mcqueen.width / 2;
    const mcqueenY = mouseY - mcqueen.height / 2;

    // Update Lightning McQueen's position
    mcqueen.style.left = `${mcqueenX}px`;
    mcqueen.style.top = `${mcqueenY}px`;
});

console.log('Lightning McQueen is now chasing your mouse! ðŸš—ðŸ’¨');
    </textarea>

    <!-- Hidden textarea for Minecraft code -->
    <textarea id="minecraftCode">
(function () {
    // Physics settings
    let objects = [];
    let gravity = 0.5;
    let friction = 0.99;
    let bounce = 0.6;

    // Array of possible image URLs (updated first image)
    const images = [
        'https://i.pinimg.com/736x/29/72/4b/29724bea77050ea1bbc34135285a9a7d.jpg', // New first image
        'https://i.redd.it/72m4shb3qh221.jpg', // Random image
        'https://i.pinimg.com/originals/d3/5c/0c/d35c0c58fff90987e9532e808ded0008.jpg', // New Stone Block
        'https://thumbs.dreamstime.com/b/pixel-minecraft-style-land-block-background-concept-game-pixelated-seamless-square-beige-material-vector-illustration-212305525.jpg' // Pixelated Land Block
    ];

    // Function to randomly select an image from the array
    function getRandomImage() {
        const randomIndex = Math.floor(Math.random() * images.length);
        return images[randomIndex];
    }

    // Function to create a block (with random image)
    function spawnBlock(x, y) {
        let img = document.createElement("img");
        img.src = getRandomImage();
        img.style.position = "absolute";
        img.style.width = "50px";  // Image width
        img.style.height = "50px"; // Image height
        img.style.left = `${x}px`;
        img.style.top = `${y}px`;
        img.style.cursor = "grab";
        document.body.appendChild(img);

        let obj = {
            element: img,
            x: x,
            y: y,
            width: 50,   // Hitbox width matches image size
            height: 50,  // Hitbox height matches image size
            velocityX: (Math.random() - 0.5) * 5, // Random horizontal speed
            velocityY: 0,
            isDragging: false
        };

        img.onmousedown = (e) => startDrag(e, obj);
        objects.push(obj);
    }

    // Spawn multiple blocks with random images
    for (let i = 0; i < 10; i++) {
        spawnBlock(Math.random() * window.innerWidth * 0.8, Math.random() * window.innerHeight * 0.5);
    }

    // Dragging logic
    let draggedObject = null;
    let offsetX = 0, offsetY = 0;

    function startDrag(e, obj) {
        draggedObject = obj;
        offsetX = e.clientX - obj.x;
        offsetY = e.clientY - obj.y;
        obj.isDragging = true;
        obj.velocityX = 0;
        obj.velocityY = 0;
        obj.element.style.cursor = "grabbing";
    }

    document.onmouseup = () => {
        if (draggedObject) {
            draggedObject.isDragging = false;
            draggedObject.element.style.cursor = "grab";
        }
        draggedObject = null;
    };

    document.onmousemove = (e) => {
        if (draggedObject) {
            draggedObject.x = e.clientX - offsetX;
            draggedObject.y = e.clientY - offsetY;
        }
    };

    // Collision detection
    function checkCollision(objA, objB) {
        return (
            objA.x < objB.x + objB.width &&
            objA.x + objA.width > objB.x &&
            objA.y < objB.y + objB.height &&
            objA.y + objA.height > objB.y
        );
    }

    // Collision response
    function resolveCollision(objA, objB) {
        let overlapX = Math.min(
            objA.x + objA.width - objB.x,
            objB.x + objB.width - objA.x
        );
        let overlapY = Math.min(
            objA.y + objA.height - objB.y,
            objB.y + objB.height - objA.y
        );

        if (overlapX < overlapY) {
            // Horizontal collision
            if (objA.x < objB.x) {
                objA.x -= overlapX / 2;
                objB.x += overlapX / 2;
            } else {
                objA.x += overlapX / 2;
                objB.x -= overlapX / 2;
            }
            objA.velocityX *= -bounce;
            objB.velocityX *= -bounce;
        } else {
            // Vertical collision
            if (objA.y < objB.y) {
                objA.y -= overlapY / 2;
                objB.y += overlapY / 2;
            } else {
                objA.y += overlapY / 2;
                objB.y -= overlapY / 2;
            }
            objA.velocityY *= -bounce;
            objB.velocityY *= -bounce;
        }
    }

    // Physics loop
    function updatePhysics() {
        for (let i = 0; i < objects.length; i++) {
            let objA = objects[i];

            if (!objA.isDragging) {
                objA.velocityY += gravity; // Apply gravity
                objA.velocityX *= friction; // Apply friction
                objA.velocityY *= friction;

                objA.x += objA.velocityX;
                objA.y += objA.velocityY;

                // Collision with window boundaries
                if (objA.x < 0) {
                    objA.x = 0;
                    objA.velocityX *= -bounce;
                }
                if (objA.x + objA.width > window.innerWidth) {
                    objA.x = window.innerWidth - objA.width;
                    objA.velocityX *= -bounce;
                }
                if (objA.y + objA.height > window.innerHeight) {
                    objA.y = window.innerHeight - objA.height;
                    objA.velocityY *= -bounce;
                }
            }

            // Check for collisions between objects
            for (let j = i + 1; j < objects.length; j++) {
                let objB = objects[j];

                if (checkCollision(objA, objB)) {
                    resolveCollision(objA, objB);
                }
            }

            // Update position
            objA.element.style.left = `${objA.x}px`;
            objA.element.style.top = `${objA.y}px`;
        }

        requestAnimationFrame(updatePhysics);
    }

    // Add more blocks when the spacebar is pressed
    document.addEventListener("keydown", function(event) {
        if (event.code === "Space") {
            for (let i = 0; i < 5; i++) {  // Spawn 5 new blocks on each press
                spawnBlock(Math.random() * window.innerWidth * 0.8, Math.random() * window.innerHeight * 0.5);
            }
        }
    });

    updatePhysics();
})();
    </textarea>

    <!-- Hidden textarea for Ants code -->
    <textarea id="antsCode">
(function() {
  // Create a style for the ants
  const style = document.createElement('style');
  style.innerHTML = `
    .ant {
      width: 10px;
      height: 10px;
      position: absolute;
      background-color: black;
      border-radius: 50%;
    }
  `;
  document.head.appendChild(style);

  // Function to generate ants
  function createAnt() {
    const ant = document.createElement('div');
    ant.classList.add('ant');
    document.body.appendChild(ant);

    // Randomly position ants within the view
    const x = Math.random() * window.innerWidth;
    const y = Math.random() * window.innerHeight;
    ant.style.left = `${x}px`;
    ant.style.top = `${y}px`;

    // Function to check if an element is too close to the edge
    function isElementNearEdge(element) {
      const rect = element.getBoundingClientRect();
      const edgeBuffer = 1; // Minimum distance from the edge of the screen (in pixels)

      // Check if the element is too close to the screen edges
      return (
        rect.top < edgeBuffer || rect.left < edgeBuffer ||
        rect.bottom > window.innerHeight - edgeBuffer ||
        rect.right > window.innerWidth - edgeBuffer
      );
    }

    // Filter the elements that are either images, buttons, or contain text
    function isValidTarget(element) {
      // Check for images
      if (element.tagName.toLowerCase() === 'img') {
        return true;
      }
      // Check for buttons
      if (element.tagName.toLowerCase() === 'button') {
        return true;
      }
      // Check for text-containing elements (like div, p, span, etc.)
      if (element.textContent.trim().length > 0) {
        return true;
      }
      return false;
    }

    // Randomly pick an element from the page that is not near the edge and is a valid target
    const elements = Array.from(document.querySelectorAll('*')).filter(el =>
      !isElementNearEdge(el) && isValidTarget(el)
    );
    const targetElement = elements[Math.floor(Math.random() * elements.length)];

    if (!targetElement || targetElement === ant) {
      // If no element found or the ant picked itself, try again
      return createAnt();
    }

    // Get the position of the selected element
    const targetRect = targetElement.getBoundingClientRect();
    const targetX = targetRect.left + targetRect.width / 2;
    const targetY = targetRect.top + targetRect.height / 2;

    // Move the ant towards the selected element (simulate pickup)
    setTimeout(() => {
      ant.style.transition = 'all 2s ease-in-out';
      ant.style.left = `${targetX - 5}px`;
      ant.style.top = `${targetY - 5}px`;

      // After reaching the object, simulate the "pickup" by moving the element with the ant
      setTimeout(() => {
        // Attach the element to the ant's position (simulate pickup)
        targetElement.style.position = 'absolute';
        targetElement.style.left = `${targetX - 5}px`;
        targetElement.style.top = `${targetY - 5}px`;
        document.body.appendChild(targetElement);

        // Then move the ant and the object off-screen
        setTimeout(() => {
          ant.style.transition = 'all 3s ease-in-out';
          ant.style.left = `${Math.random() > 0.5 ? -200 : window.innerWidth + 200}px`;
          ant.style.top = `${Math.random() > 0.5 ? -200 : window.innerHeight + 200}px`;

          // Move the target object off-screen as well
          targetElement.style.transition = 'all 3s ease-in-out';
          targetElement.style.left = `${Math.random() > 0.5 ? -200 : window.innerWidth + 200}px`;
          targetElement.style.top = `${Math.random() > 0.5 ? -200 : window.innerHeight + 200}px`;

          // Remove the object and the ant from the DOM after they have moved off-screen
          setTimeout(() => {
            targetElement.remove(); // Remove the object
            ant.remove(); // Remove the ant
          }, 3000);
        }, 2000);
      }, 2000);
    }, 0);
  }

  // Spawn three ants every second
  setInterval(() => {
    createAnt();
    createAnt();
    createAnt();
  }, 1000);  // Every 1000ms (1 second)
})();
    </textarea>

    <!-- Hidden textarea for Fish code -->
    <textarea id="fishCode">
(() => {
    const fishCount = 10;
    const lilyPadCount = 5;
    const fishSpeed = 1.5
    const scareDistance = 100;
    const fishSize = 80;
    const lilyPadSize = 60;
    const fishImage = 'https://lagunakoi.com/wp-content/uploads/2024/12/Photoroom_20241210_110354.png';
    const lilyPadImage = 'https://static.vecteezy.com/system/resources/previews/046/622/130/non_2x/water-lily-flower-and-leaf-png.png';
    const foodSize = 5;
    const foodFloatSpeed = 0.3;
    const foodAttractRadius = 150;
    const lilyPadFloatSpeed = 0.1;

    let fishArray = [];
    let lilyPadArray = [];
    let foodArray = [];

    document.addEventListener("click", (e) => {
        spawnFood(e.clientX, e.clientY);
    });

    function createOverlay() {
        const overlay = document.createElement("div");
        overlay.style.position = "fixed";
        overlay.style.top = "0";
        overlay.style.left = "0";
        overlay.style.width = "100vw";
        overlay.style.height = "100vh";
        overlay.style.backgroundColor = "rgba(0, 100, 255, 0.15)"; // Transparent blue water effect
        overlay.style.pointerEvents = "none";
        overlay.style.zIndex = "2"; // Above background, below lily pads and fish
        document.body.appendChild(overlay);
    }

    function createLilyPad() {
        const lilyPad = document.createElement("img");
        lilyPad.src = lilyPadImage;
        lilyPad.style.position = "absolute";
        lilyPad.style.width = `${lilyPadSize}px`;
        lilyPad.style.transformOrigin = "center";
        lilyPad.style.left = `${Math.random() * (window.innerWidth - lilyPadSize)}px`;
        lilyPad.style.top = `${Math.random() * (window.innerHeight - lilyPadSize)}px`;
        lilyPad.style.zIndex = "3"; // Above water, below fish
        document.body.appendChild(lilyPad);

        return {
            element: lilyPad,
            x: parseFloat(lilyPad.style.left),
            y: parseFloat(lilyPad.style.top),
            angle: Math.random() * 360,
        };
    }

    function updateLilyPad(lilyPad) {
        lilyPad.x += Math.cos(lilyPad.angle * (Math.PI / 180)) * lilyPadFloatSpeed;
        lilyPad.y += Math.sin(lilyPad.angle * (Math.PI / 180)) * lilyPadFloatSpeed;
        lilyPad.element.style.left = `${lilyPad.x}px`;
        lilyPad.element.style.top = `${lilyPad.y}px`;
    }

    function createFood(x, y) {
        const food = document.createElement("div");
        food.style.position = "absolute";
        food.style.width = `${foodSize}px`;
        food.style.height = `${foodSize}px`;
        food.style.backgroundColor = "yellow";
        food.style.borderRadius = "50%";
        food.style.left = `${x}px`;
        food.style.top = `${y}px`;
        food.style.zIndex = "4"; // Above blur but below fish
        document.body.appendChild(food);

        return {
            element: food,
            x: x,
            y: y,
            angle: Math.random() * 360,
        };
    }

    function spawnFood(x, y) {
        const numFoodParticles = 5;
        for (let i = 0; i < numFoodParticles; i++) {
            foodArray.push(createFood(x, y));
        }
    }

    function updateFood(food) {
        food.x += Math.cos(food.angle * (Math.PI / 180)) * foodFloatSpeed;
        food.y += Math.sin(food.angle * (Math.PI / 180)) * foodFloatSpeed;
        food.angle += (Math.random() - 0.5) * 10;
        
        food.x = Math.max(0, Math.min(window.innerWidth - foodSize, food.x));
        food.y = Math.max(0, Math.min(window.innerHeight - foodSize, food.y));

        food.element.style.left = `${food.x}px`;
        food.element.style.top = `${food.y}px`;
    }

    function createFish(container) {
        const fish = document.createElement("img");
        fish.src = fishImage;
        fish.style.position = "absolute";
        fish.style.width = `${fishSize}px`;
        fish.style.transformOrigin = "center";
        fish.style.transition = "transform 0.2s linear";
        fish.style.left = `${Math.random() * (window.innerWidth - fishSize)}px`;
        fish.style.top = `${Math.random() * (window.innerHeight - fishSize)}px`;
        fish.style.zIndex = "5"; // Above water and lily pads
        container.appendChild(fish);

        return {
            element: fish,
            x: parseFloat(fish.style.left),
            y: parseFloat(fish.style.top),
            angle: Math.random() * 360,
            speed: fishSpeed,
        };
    }

    function updateFish(fish) {
        let closestFood = null;
        let minDist = Infinity;

        foodArray.forEach(food => {
            const dx = food.x - fish.x;
            const dy = food.y - fish.y;
            const dist = Math.hypot(dx, dy);
            if (dist < minDist && dist < foodAttractRadius) {
                minDist = dist;
                closestFood = food;
            }
        });

        if (closestFood) {
            const dx = closestFood.x - fish.x;
            const dy = closestFood.y - fish.y;
            fish.angle = Math.atan2(dy, dx) * (180 / Math.PI);
            fish.speed = fishSpeed * 2;

            if (minDist < foodSize) {
                closestFood.element.remove();
                foodArray = foodArray.filter(item => item !== closestFood);
            }
        } else {
            fish.angle += (Math.random() - 0.5) * 20;
            fish.speed = fishSpeed;
        }

        fish.x += Math.cos(fish.angle * (Math.PI / 180)) * fish.speed;
        fish.y += Math.sin(fish.angle * (Math.PI / 180)) * fish.speed;

        fish.x = Math.max(0, Math.min(window.innerWidth - fishSize, fish.x));
        fish.y = Math.max(0, Math.min(window.innerHeight - fishSize, fish.y));

        fish.element.style.left = `${fish.x}px`;
        fish.element.style.top = `${fish.y}px`;
        fish.element.style.transform = `rotate(${fish.angle - 45}deg)`;
    }

    function animate() {
        fishArray.forEach(updateFish);
        lilyPadArray.forEach(updateLilyPad);
        foodArray.forEach(updateFood);
        requestAnimationFrame(animate);
    }

    function createContainer(zIndex) {
        const container = document.createElement("div");
        container.style.position = "fixed";
        container.style.top = "0";
        container.style.left = "0";
        container.style.width = "100vw";
        container.style.height = "100vh";
        container.style.zIndex = zIndex;
        document.body.appendChild(container);
        return container;
    }

    createOverlay();
    const fishContainer = createContainer(5);
    fishArray = Array.from({ length: fishCount }, () => createFish(fishContainer));
    lilyPadArray = Array.from({ length: lilyPadCount }, createLilyPad);
    animate();
})();
    </textarea>

    <!-- Hidden textarea for Space code -->
    <textarea id="spaceCode">
// Create letters (instead of particles)
let letters = [];
let gravityStrength = 5000; // Gravity strength
let minForce = 0.5; // Minimum force to apply, even for distant letters
let maxSpeed = 10; // Max speed for slower movement
let screenWidth = window.innerWidth;
let screenHeight = window.innerHeight;

let cursorX = screenWidth / 2; // Initial cursor position
let cursorY = screenHeight / 2; // Initial cursor position
let maxLetters = 250; // Maximum number of letters

// Get all the text nodes and extract letters
function getTextLetters() {
  let textNodes = [];
  let walk = document.createTreeWalker(
    document.body,
    NodeFilter.SHOW_TEXT,
    null,
    false
  );

  while (walk.nextNode()) {
    textNodes.push(walk.currentNode);
  }

  let letterArray = [];
  textNodes.forEach(node => {
    // Split text content of each node into individual letters (characters) and exclude spaces
    letterArray.push(...node.textContent.replace(/\s+/g, '').split(''));
  });

  return { textNodes, letterArray };
}

// Get all font families, colors, and font sizes used on the website
function getStyles() {
  const allElements = document.querySelectorAll('*');
  const fonts = new Set(); // To store unique fonts
  const colors = new Set(); // To store unique colors
  const fontSizes = new Set(); // To store unique font sizes

  allElements.forEach(element => {
    const fontFamily = window.getComputedStyle(element).fontFamily;
    const color = window.getComputedStyle(element).color;
    const fontSize = window.getComputedStyle(element).fontSize;

    fonts.add(fontFamily); // Add the font family to the set
    colors.add(color); // Add the color to the set
    fontSizes.add(fontSize); // Add the font size to the set
  });

  return {
    fonts: Array.from(fonts),
    colors: Array.from(colors),
    fontSizes: Array.from(fontSizes),
  };
}

// Replace each letter with a floating version and remove the original text
function createLetters() {
  let { textNodes, letterArray } = getTextLetters();
  let count = Math.min(letterArray.length, maxLetters); // Limit the number of letters to maxLetters
  const { fonts, colors, fontSizes } = getStyles(); // Get styles used on the page

  // Loop through each letter and replace it
  for (let i = 0; i < count; i++) {
    let letter = letterArray[i];
    let span = document.createElement('span');
    span.textContent = letter;
    span.style.position = 'absolute';
    span.style.transition = 'none'; // Disable transition for smooth movement
    span.style.zIndex = '9999';

    // Assign a random font, color, and font size from the styles
    span.style.fontFamily = fonts[Math.floor(Math.random() * fonts.length)];
    span.style.color = colors[Math.floor(Math.random() * colors.length)];
    span.style.fontSize = fontSizes[Math.floor(Math.random() * fontSizes.length)];

    // Get random off-screen starting position
    let x = Math.random() * screenWidth * 2 - screenWidth; // Random x position outside the screen
    let y = Math.random() * screenHeight * 2 - screenHeight; // Random y position outside the screen

    // Set initial position for the letter to appear from off-screen
    span.style.left = `${x}px`;
    span.style.top = `${y}px`;

    // Append the letter to the page
    document.body.appendChild(span);

    // Remove the original text node after replacing it with a span
    textNodes[i].parentNode.removeChild(textNodes[i]);

    // Store the letter's data for gravitational physics
    letters.push({
      element: span,
      x: x,  // Initial X position
      y: y,  // Initial Y position
      vx: 0, // No initial velocity
      vy: 0, // No initial velocity
      ax: 0, // Initial acceleration
      ay: 0, // Initial acceleration
    });
  }
}

// Track mouse position
document.addEventListener('mousemove', (e) => {
  cursorX = e.clientX;
  cursorY = e.clientY;
});

// Update letters based on gravity force from the cursor
function updateLetters() {
  letters.forEach(letter => {
    // Calculate distance between letter and cursor
    let dx = cursorX - letter.x;
    let dy = cursorY - letter.y;
    let distance = Math.sqrt(dx * dx + dy * dy);

    // Avoid extremely small distance values to prevent very large forces
    if (distance < 100) {
      distance = 100; // Prevent divide by zero or extreme values
    }

    // Gravitational force: stronger as letters get closer to the cursor
    let force = gravityStrength / (distance * distance); // Inverse square law

    // Apply minimum force threshold
    force = Math.max(force, minForce); // Make sure force never goes below the minimum

    // Calculate acceleration based on the gravitational force
    let ax = (dx / distance) * force;
    let ay = (dy / distance) * force;

    // Apply acceleration to velocity (simulating falling)
    letter.ax = ax;
    letter.ay = ay;

    // Apply acceleration to velocity
    letter.vx += letter.ax;
    letter.vy += letter.ay;

    // Limit the maximum velocity to prevent runaway speeds
    let speed = Math.sqrt(letter.vx * letter.vx + letter.vy * letter.vy);
    if (speed > maxSpeed) {
      let scale = maxSpeed / speed;
      letter.vx *= scale;
      letter.vy *= scale;
    }

    // Update letter positions based on velocity
    letter.x += letter.vx;
    letter.y += letter.vy;

    // Apply new position to the letter
    letter.element.style.left = letter.x - 10 + 'px'; // Center the letter
    letter.element.style.top = letter.y - 10 + 'px'; // Center the letter
  });
}

// Game loop to update letters every frame
function gameLoop() {
  screenWidth = window.innerWidth; // Update screen width on resize
  screenHeight = window.innerHeight; // Update screen height on resize
  updateLetters();
  requestAnimationFrame(gameLoop);
}

// Initialize the letter animations
createLetters();
gameLoop();
    </textarea>

    <script>
        // Function to copy the DVD-logo code
        async function copyDVDCode() {
            const dvdCodeTextarea = document.getElementById('dvdCode');
            try {
                await navigator.clipboard.writeText(dvdCodeTextarea.value);
                alert('DVD-logo code copied to clipboard!');
            } catch (err) {
                console.error('Failed to copy code: ', err);
                alert('Failed to copy code. Please manually copy the code from the textarea.');
            }
        }

        // Function to copy the Shrek code
        async function copyShrekCode() {
            const shrekCodeTextarea = document.getElementById('shrekCode');
            try {
                await navigator.clipboard.writeText(shrekCodeTextarea.value);
                alert('Shrek code copied to clipboard!');
            } catch (err) {
                console.error('Failed to copy code: ', err);
                alert('Failed to copy code. Please manually copy the code from the textarea.');
            }
        }

        // Function to copy the Kachow code
        async function copyKachowCode() {
            const kachowCodeTextarea = document.getElementById('kachowCode');
            try {
                await navigator.clipboard.writeText(kachowCodeTextarea.value);
                alert('Kachow code copied to clipboard!');
            } catch (err) {
                console.error('Failed to copy code: ', err);
                alert('Failed to copy code. Please manually copy the code from the textarea.');
            }
        }

        // Function to copy the Minecraft code
        async function copyMinecraftCode() {
            const minecraftCodeTextarea = document.getElementById('minecraftCode');
            try {
                await navigator.clipboard.writeText(minecraftCodeTextarea.value);
                alert('Minecraft code copied to clipboard!');
            } catch (err) {
                console.error('Failed to copy code: ', err);
                alert('Failed to copy code. Please manually copy the code from the textarea.');
            }
        }

        // Function to copy the Ants code
        async function copyAntsCode() {
            const antsCodeTextarea = document.getElementById('antsCode');
            try {
                await navigator.clipboard.writeText(antsCodeTextarea.value);
                alert('Ants code copied to clipboard!');
            } catch (err) {
                console.error('Failed to copy code: ', err);
                alert('Failed to copy code. Please manually copy the code from the textarea.');
            }
        }

        // Function to copy the Fish code
        async function copyFishCode() {
            const fishCodeTextarea = document.getElementById('fishCode');
            try {
                await navigator.clipboard.writeText(fishCodeTextarea.value);
                alert('Fish code copied to clipboard!');
            } catch (err) {
                console.error('Failed to copy code: ', err);
                alert('Failed to copy code. Please manually copy the code from the textarea.');
            }
        }

        // Function to copy the Space code
        async function copySpaceCode() {
            const spaceCodeTextarea = document.getElementById('spaceCode');
            try {
                await navigator.clipboard.writeText(spaceCodeTextarea.value);
                alert('Space code copied to clipboard!');
            } catch (err) {
                console.error('Failed to copy code: ', err);
                alert('Failed to copy code. Please manually copy the code from the textarea.');
            }
        }
    </script>
</body>
</html>f54
